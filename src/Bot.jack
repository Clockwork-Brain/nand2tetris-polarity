//  ================================================================================
//                                     class Bot
//  ================================================================================

/**
 *  The player character.
 *
 *  During normal gameplay, the player character only moves up and down in
 *  a single column on the screen. This allows things like collision detection
 *  to be simplified; for example, the CellState needs to maintain only one
 *  column of world state.
 *
 *  The update method of the Bot handles normal movement, picking up chips, and
 *  deciding which sprite to draw. (See Sprites.jack.)
 *
 *  The test_failure method detects failure conditions (obstacle hit or battery
 *  drained), draws the appropriate sprite if one of these conditions occurs,
 *  and reports the outcome to the caller.
 *
 *
 *  Important Constants
 *  ===================
 *
 *  BOT_COLUMN = 4     // the screen column of the bot during the game
 *  BATTERY_MAX = 127  // the maximum battery level
 *
 */
class Bot {

	//  ----------------------------------------------------------------------------
	//                                     FIELDS
	//  ----------------------------------------------------------------------------

	//  Battery level (between 0 and BATTERY_MAX).
	//
	field int battery_level;

	//  ----------------------------------------------------------------------------

	//  True if the bot is walking on a charger.
	//  Used for drawing the active charger sprite.
	//
	field bool charging;

	//  ----------------------------------------------------------------------------

	//  Position of the bot.
	//  It is two cells tall; the top_row field indicates the topmost occupied
	//  cell, regardless of the bot's orientation.
	//
	field int top_row;
	field int column;

	//  ----------------------------------------------------------------------------

	//  Orientation: if true, the bot is upside down.
	//
	field bool orientation;

	//  ----------------------------------------------------------------------------

	//  The visual orientation is tracked separately, and lags one frame behind
	//  the actual orientation. This makes it seem like the bot jumps off the
	//  surface it was on before flipping over.
	//
	field bool visual_orientation;

	//  ----------------------------------------------------------------------------

	//  Whether the bot is falling.
	//  Controls the sprite drawn by the draw function.
	//
	field bool falling;

	//  ----------------------------------------------------------------------------
	//                          INITIALIZATION AND DISPOSAL
	//  ----------------------------------------------------------------------------

	/**
	 *  Returns an **un-initialized** Bot instance.
	 *
	 *  The reset method must be called to put the instance in a valid state
	 *  after construction.
	 */
	constructor Bot new() {
		return this;
	}

	/**
	 *  Disposes a Bot instance.
	 */
	method void dispose() {
		do Memory.deAlloc(this);
		return;
	}

	//  ----------------------------------------------------------------------------

	/**
	 *  (Re)initializes the Bot's fields to valid values.
	 *
	 *  The bot is placed on the floor in its default screen column. The floor
	 *  height is determined by inspecting the provided cell_state.
	 */
	method void reset(CellState cell_state) {
		let orientation = false;
		let visual_orientation = false;
		let falling = false;

		// Set battery level to BATTERY_MAX
		let battery_level = 127;

		// Place in column BOT_COLUMN
		let column = 4;

		// Set height to bottom of world,
		// then scan up until an empty cell is found.
		let top_row = 13;
		while (cell_state.is_cell_solid(top_row + 1)) {
			let top_row = top_row - 1;
		}

		return;
	}

	//  ----------------------------------------------------------------------------
	//                                   PROPERTIES
	//  ----------------------------------------------------------------------------

	/**
	 *  Returns the current battery level.
	 */
	method int get_battery_level() {
		return battery_level;
	}

	/**
	 *  Changes the column where the bot's sprite is drawn.
	 *
	 *  This is a purely visual change, used during the stage completion
	 *  animation. It should not be used during normal gameplay.
	 */
	method void set_display_column(int new_column) {
		let column = new_column;
		return;
	}

	/**
	 *  Tells the bot to flip its orientation.
	 *
	 *  This method has an effect only if the bot is not falling, and if it has
	 *  enough battery left.
	 *
	 *  On a successful flip, it sets the falling field to true.
	 */
	method void flip() {
		if (~(falling)) {
			if (battery_level > 8) {
				let battery_level = battery_level - 6;
				let orientation = ~orientation;
				let falling = true;
			} else {
				let battery_level = 0;
			}
		}
		return;
	}

	//  ----------------------------------------------------------------------------
	//                                 UPDATE METHOD
	//  ----------------------------------------------------------------------------

	/**
	 *  Updates the bot for the next game frame.
	 *
	 *  This method also erases the bot graphic at the start of the update, and
	 *  redraws it in its new position at the end of the update.
	 *
	 *  The bot must be in a valid state when this method is called: not broken,
	 *  battery not drained, and there must be no stage completed sequence
	 *  playing.
	 */
	method void update(int frame, CellState cell_state) {
		var int prev_top_row;
		var int floor_row;

		do _collect_chip(cell_state, top_row);
		do _collect_chip(cell_state, top_row + 1);

		let prev_top_row = top_row;
		if (orientation) {
			let floor_row = top_row - 1;
		} else {
			let floor_row = top_row + 2;
		}

		do erase();

		let visual_orientation = orientation;
		let charging = false;

		if (cell_state.is_cell_solid(floor_row)) {
			let falling = false;

			// Check if standing on a CHARGER cell;
			// recharge if less than BATTERY_MAX.
			//
			if (cell_state.get_cell(floor_row) = 3) {
				let charging = true;
				let battery_level = battery_level + 4;
				if (battery_level > 127) {
					let battery_level = 127;
				}
			} else {
				if (battery_level > 0) {
					let battery_level = battery_level - 1;
				}
			}
		} else {
			let falling = true;
			if (orientation) {
				let top_row = top_row - 1;
				do _collect_chip(cell_state, top_row);
			} else {
				let top_row = top_row + 1;
				do _collect_chip(cell_state, top_row + 1);
			}
		}

		do draw(frame);
		return;
	}

	//  ----------------------------------------------------------------------------

	//  Looks if there is a chip in the given cell, and picks it up if there is.
	//  Used by the update method.
	//
	method void _collect_chip(CellState cell_state, int p_row) {
		// Find CHIP_SMALL
		if (cell_state.get_cell(p_row) = 8) {
			do Stats.add_score(5);
			do cell_state.put_cell(p_row, 0); // EMPTY
		}
		// Find CHIP_BIG
		if (cell_state.get_cell(p_row) = 10) {
			do Stats.add_score(20);
			do cell_state.put_cell(p_row, 0); // EMPTY
		}
		return;
	}

	//  ----------------------------------------------------------------------------
	//                               FAILURE DETECTION
	//  ----------------------------------------------------------------------------

	/**
	 *  Tests for failure conditions.
	 *
	 *  If a failure condition is reached, it also draws an appropriate bot
	 *  graphic.
	 *
	 *  Returns:
	 *  -  0: no problem
	 *  -  1: hit an obstacle
	 *  -  2: battery drained
	 */
	method int test_failure(CellState cell_state) {
		if (~(
			(cell_state.get_cell(top_row) = 0)
			& (cell_state.get_cell(top_row + 1) = 0)
		)) {
			if (orientation) {
				do Sprites.draw_bot_up_broken(top_row, column);
			} else {
				do Sprites.draw_bot_down_broken(top_row, column);
			}
			return 1;
		}

		if ((~falling) & (battery_level = 0)) {
			if (orientation) {
				do Sprites.draw_bot_up_frame0(top_row, column);
				do Sprites.draw_bot_up_face_drained(top_row + 1, column);
			} else {
				do Sprites.draw_bot_down_frame0(top_row, column);
				do Sprites.draw_bot_down_face_drained(top_row, column);
			}
			return 2;
		}

		return 0;
	}

	//  ----------------------------------------------------------------------------
	//                                    VISUALS
	//  ----------------------------------------------------------------------------

	/**
	 *  Draws the bot on the screen.
	 *
	 *  The frame parameter is the current game frame. This is used for the
	 *  walking animation.
	 */
	method void draw(int frame) {
		if (charging) {
			if (visual_orientation) {
				do Sprites.draw_charger_on(top_row - 1, column);
			} else {
				do Sprites.draw_charger_on(top_row + 2, column);
			}
		}

		if (falling | ((frame & 2) = 2)) {
			if (visual_orientation) {
				do Sprites.draw_bot_up_frame1(top_row, column);
			} else {
				do Sprites.draw_bot_down_frame1(top_row, column);
			}
		} else {
			if (visual_orientation) {
				do Sprites.draw_bot_up_frame0(top_row, column);
			} else {
				do Sprites.draw_bot_down_frame0(top_row, column);
			}
		}
		return;
	}

	/**
	 *  Removes the bot from the screen.
	 */
	method void erase() {
		if (charging) {
			if (visual_orientation) {
				do Sprites.draw_charger_off(top_row - 1, column);
			} else {
				do Sprites.draw_charger_off(top_row + 2, column);
			}
		}

		do Sprites.draw_empty(top_row, column);
		do Sprites.draw_empty(top_row + 1, column);
		return;
	}

}   //  ============================================================================
